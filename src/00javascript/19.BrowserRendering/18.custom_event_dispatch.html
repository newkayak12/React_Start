<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
	<script>
		/**
		 * 생성된 커스텀 이벤트는 dispatchEvent 메소드로서 디스패치 (이벤트를 발생시키는 행위) 할 수 있다. dispatchEvent 메소드에 이벤트 객체를 인수로 전달하면서 호출하면 인수로 전달한 이벤트 타입의 이벤트가 발생한다.
		 */ 
	</script>
	<button class='btn'>click me</button>
	<script>
		const $btn = document.querySelector('.btn');

		//버튼 요소에 foo 커스텀 이벤트 핸들러를 등록
		//커스텀 이벤트를 디스패치하기 이전에 이벤트 핸들러를 등록해야한다.
		$btn.addEventListener('click', e =>{
			console.log(e)
			alert(`${e} clicked`)
		})

		//커스텀 이벤트 생성
		// const customEvent = new MouseEvent('click')

		//커스텀 이벤트 디스패치(동기 처리). click 이벤트가 발생한다.
		// $btn.dispatchEvent(customEvent);
		/**
		 * 일반적으로 이벤트 핸들러는 비동기 처리 방식으로 동작하지만 dispatchEvent 메소드는 이벤트 핸들러를 동기 처리 방식으로 호출한다. 다시 말해, dispatchEvent 메소드를 호출하면 커스텀 이벤트에
		 * 바인딩된 이벤트 핸들러를 직접 호출하는 것과 같다. 따라서 dispatchEvent 메소드로 이벤트를 디스패치 하기 이전에 커스텀 이벤트를 처리할 이벤트 핸들러를 등록해야한다.
		 */  

		//  customEvent 생성자 함수로 foo이벤타 타입의 커스텁 이벤트 객체를 생성
		// const customEvent = new CustomEvent('foo')
		// console.log(customEvent.type)//foo

		/**
		 * 이떄 customEvent 이벤트 생성자 함수에는 두 번째 인수로 이벤트와 함께 전달하고 싶은 정보를 담은 detail프로퍼티를 포함하는 객체를 전달할 수 있다.
		 * 이 정보는 이벤트 객체의 detail 프로퍼티(e.detail)에 담겨 전달된다.
		 */ 

		 $btn.addEventListener('foo', e =>{
			alert(`${e.detail.message}`)
		})

		//CustomEvent 생성자 함수로 foo이벤트 타입의 커스텀 이벤트 객체를 생성
		const customEvent = new CustomEvent('foo',{
			detail:{message:'HELLO!'} // 이벤트와 함계 전달하고 싶은 정보
		})

		//커스텀 이벤트 디스패치
		$btn.dispatchEvent(customEvent)

		/**
		 * 기존 이벤트 타입이 아닌 임의의 이벤트 타입을 지정하여 커스텀 이벤트 객체를 생성한 경우 반드시 addEventListener 메소드 방식으로 이벤트 핸들러를 등록해야한다.
		 * 이벤트 핸들러 어트리뷰트/프로퍼티 방식을 사용할 수 없는 이유는 'on + 이벤트 타입'으로 이루어진 이벤트 핸들러 어트리뷰트/프로퍼티가 요소 노드에 존재하지 않기 때문이다.
		 * 예를 들어, 'foo'라는 임의의 이벤트 타입으로 커스텀 이벤트를 생성한 경우 'onfoo'라는 핸들러 어트리뷰트/프로퍼티가 요소 노드에 존재하지 않기 때문에 이벤트 핸들러 어트리뷰트/프로터티
		 * 방식으로는 이벤트 핸들러를 등록할 수 없다. 
		 * 
		 */ 

	</script>
	
</body>
</html>