<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>
	<script>
		//  handleClick함수 내부의 this는 전역 객체의 window르 ㄹ가리킨다.
	</script>
	<button onclick = "handleClick(this)"> click me </button>
	<script>
		function handleClick(button){
			console.log(this)//window
			console.log(button) // 이벤트를 바인딩한 button 요소
		}
		/**
		 * 이벤트 핸들러 어트리뷰트의 값으로 지정한 문자열은 사실 암묵적으로 생성되는 이벤트 핸들러의 문이라고 했다. 
		 * 따라서 handleClick 함수는 이벤트 핸들러에 의해 일반 함수로 호출된다.
		 * 일반함수로서 호출되는 함수 내부의 this는 전역 객체를 가리킨다. 따라서 handleClick 함수 내부의 this는 전역 객체 window를 가리킨다.
		 * 단, 이벤트 핸들러를 호출할 때 인수로 전달한 this는 이벤트를 바인딩한 DOM 요소를 가리킨다. 
		 * 
		 * handleClick 함수에 전달한 this는 암묵적으로 생성된 이벤트 핸들러 내부의 this이다. 즉, 이벤트 핸들러 어트리뷰트 방식에 의해 암묵적으로 생성된 이벤트 핸들러 
		 * 내부의 this는 이벤트 바인딩한 DOM 요소를 가리킨다. 이는 이벤트 핸들러 프로퍼티 방식과 동일하다 .
		 */ 
	</script>

	<button class='btn1'>0</button>
	<button class='btn2'>0</button>]
	<script>
		const $btn1 = document.querySelector('.btn1')
		const $btn2 = document.querySelector('.btn2')
		//이벤트 핸들러 프로퍼티 방식 
		$btn1.onclick = function (e) {
			//this는 이벤트를 바인딩한 DOM 요소를 가리킨다. 
			console.log(this)//$btn1
			console.log(e.currentTarget); // $btn1
			console.log(this === e.currentTarget) // true

			//$btn1의 textCount를 1 증가시킨다.
			++this.textContent;
		};

		//addEventListener 메소드 방식
		$btn2.addEventListener('click', function (e){
			//this는 이벤트를 바인딩한 DOM 요소를 가리킨다. 
			console.log(this)//$btn2
			console.log(e.currentTarget); //$btn2
			console.log(this === e.currentTarget)// true

			//$btn2의 textCotent를 1 증가시킨다.
			++this.textContent;
		})
	</script>
</body>
</html>